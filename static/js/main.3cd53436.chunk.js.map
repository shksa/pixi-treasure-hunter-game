{"version":3,"sources":["styled-components/index.ts","AppStyle.ts","pages/TreasureHunter/helpers.ts","pages/TreasureHunter/style.ts","pages/TreasureHunter/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["styled","default","createGlobalStyle","css","ThemeProvider","keyframes","Direction","GlobalStyle","_templateObject","theme","primaryColor","primaryColorInverted","background","AppWrapper","div","withConfig","displayName","componentId","Page","PixiViewWrapper","randomNumberInBetween","min","max","Math","floor","random","DirectionKeys","contain","sprite","container","collision","undefined","x","left","y","top","width","right","height","bottom","hitTestRectangle","r1","r2","combinedHalfWidths","combinedHalfHeights","vx","vy","centerX","centerY","halfWidth","halfHeight","abs","keyboard","value","key","isDown","isUp","press","release","downHandler","event","preventDefault","upHandler","downListener","upListener","document","addEventListener","unsubscribe","removeEventListener","SpriteID","door","treasure","explorer","dungeon","blob","TreasureHunter","pixiLoader","PIXI","allSprites","GAME_WIDTH","GAME_HEIGHT","NumberOfBlobs","DungeonWallWidth","HealthBarWidth","HealthBarHeight","resize","ratio","window","innerWidth","_this","innerHeight","pixiApp","stage","scale","renderer","ceil","console","log","devicePixelRatio","resolution","setupGame","backgroundColor","autoResize","antialias","view","style","position","pixiViewWrapperEle","appendChild","add","name","url","load","setupGameScenes","loader","resources","playScene","gameOverScene","visible","setupPlayGameScene","setupGameOverScene","gameState","play","ticker","gameLoop","gameTextures","GameTextureAtlas","textures","createSpriteAndAddToPlayScene","bindKeyboardArrowKeysToExplorerMoves","createBlobSprites","createHealthBar","movablePlaySceneAreaDims","addChild","spriteID","spriteName","substring","length","ArrowLeft","up","ArrowUp","ArrowRight","down","ArrowDown","blobSpritesArray","Array","from","forEach","_","idx","array","blobSprite","blobs","positionBlobsRandomly","offsetFromWall","direction","healthBarContainer","label","fontFamily","fontSize","fill","set","innerBar","beginFill","drawRect","endFill","outerBar","healthBarXPosition","outer","gameOverSceneMessage","deltaTime","_this$allSprites","isExplorerHit","blobHitsWall","alpha","end","text","componentDidMount","_this2","this","react_default","a","createElement","ref","React","Component","App","s","Fragment","TreasureHunter_TreasureHunter","Boolean","location","hostname","match","ReactDOM","render","App_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3cd53436.chunk.js","sourcesContent":["import * as styledComponents from \"styled-components\";\nimport { ThemedStyledComponentsModule } from \"styled-components\";\n\nimport ThemeInterface from \"./theme\";\n\nconst {\n  default: styled,\n  css,\n  createGlobalStyle,\n  keyframes,\n  ThemeProvider\n} = styledComponents as ThemedStyledComponentsModule<ThemeInterface>;\n\nexport { css, createGlobalStyle, keyframes, ThemeProvider };\nexport default styled;","import styled, {createGlobalStyle} from './styled-components'\nimport ThemeInterface from './styled-components/theme'\n\nexport const GlobalStyle = createGlobalStyle`\n  body {\n    margin: 0;\n    padding: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n      sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n  }\n\n  code {\n    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',\n      monospace;\n  }\n\n  * {\n    position: relative;\n    box-sizing: border-box;\n    padding: 0px;\n    margin: 0px;\n  }\n`;\n\nexport const theme: ThemeInterface = {\n  primaryColor: \"white\", \n  primaryColorInverted: \"black\",\n  background: \"blueviolet\"\n}\n\nexport const AppWrapper = styled.div`\n  height: 100vh;\n  width: 100vw;\n  background-color: aliceblue;\n`","import { Sprite, AreaDims } from \".\";\n\nexport const randomNumberInBetween = (min: number, max: number): number => {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nexport enum Direction {\n  left = 'left',\n  right = 'right',\n  top = 'top',\n  bottom = 'bottom'\n}\n\nexport const contain = (sprite: Sprite, container: AreaDims): Direction | undefined => {\n\n  let collision : undefined | Direction = undefined\n\n  //Left\n  if (sprite.x < container.x) {\n    sprite.x = container.x;\n    collision = Direction.left\n  }\n\n  //Top\n  if (sprite.y < container.y) {\n    sprite.y = container.y;\n    collision = Direction.top\n  }\n\n  //Right\n  if (sprite.x + sprite.width > container.width) {\n    sprite.x = container.width - sprite.width;\n    collision = Direction.right\n  }\n\n  //Bottom\n  if (sprite.y + sprite.height > container.height) {\n    sprite.y = container.height - sprite.height;\n    collision = Direction.bottom\n  }\n\n  //Return the `collision` value\n  return collision;\n}\n\nexport const hitTestRectangle = (r1: Sprite, r2: Sprite): boolean => {\n  //Define the variables we'll need to calculate\n  let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;\n\n  //hit will determine whether there's a collision\n  hit = false;\n\n  //Find the center points of each sprite\n  r1.centerX = r1.x + r1.width / 2;\n  r1.centerY = r1.y + r1.height / 2;\n  r2.centerX = r2.x + r2.width / 2;\n  r2.centerY = r2.y + r2.height / 2;\n\n  //Find the half-widths and half-heights of each sprite\n  r1.halfWidth = r1.width / 2;\n  r1.halfHeight = r1.height / 2;\n  r2.halfWidth = r2.width / 2;\n  r2.halfHeight = r2.height / 2;\n\n  //Calculate the distance vector between the sprites\n  vx = r1.centerX - r2.centerX;\n  vy = r1.centerY - r2.centerY;\n\n  //Figure out the combined half-widths and half-heights\n  combinedHalfWidths = r1.halfWidth + r2.halfWidth;\n  combinedHalfHeights = r1.halfHeight + r2.halfHeight;\n\n  //Check for a collision on the x axis\n  if (Math.abs(vx) < combinedHalfWidths) {\n\n    //A collision might be occurring. Check for a collision on the y axis\n    if (Math.abs(vy) < combinedHalfHeights) {\n\n      //There's definitely a collision happening\n      hit = true;\n    } else {\n\n      //There's no collision on the y axis\n      hit = false;\n    }\n  } else {\n\n    //There's no collision on the x axis\n    hit = false;\n  }\n\n  //`hit` will be either `true` or `false`\n  return hit;\n}\n\nexport enum DirectionKeys {\n  ArrowUp = \"ArrowUp\",\n  ArrowDown = \"ArrowDown\",\n  ArrowLeft = \"ArrowLeft\",\n  ArrowRight = \"ArrowRight\",\n}\n\nexport interface KeyObject {\n  value: DirectionKeys\n  isDown: boolean\n  isUp: boolean\n  press: (() => void) | undefined\n  release: (() => void) | undefined\n  downHandler: (event: KeyboardEvent) => void\n  upHandler: (event: KeyboardEvent) => void\n  unsubscribe: () => void\n}\n\nexport const keyboard = (value: DirectionKeys) => {\n  let key = {} as KeyObject\n  key.value = value\n  key.isDown = false\n  key.isUp = true\n  key.press = undefined\n  key.release = undefined\n\n  //The `downHandler`\n  key.downHandler = (event) => {\n    if (event.key === key.value) {\n      // console.log(`event.key: ${event.key}, key.value: ${key.value} downHandler`)\n      if (key.isUp && key.press) key.press()\n      key.isDown = true\n      key.isUp = false\n      event.preventDefault()\n    }\n  }\n\n  //The `upHandler`\n  key.upHandler = (event) => {\n    if (event.key === key.value) {\n      // console.log(`event.key: ${event.key}, key.value: ${key.value} upHandler`)\n      if (key.isDown && key.release) key.release()\n      key.isDown = false\n      key.isUp = true\n      event.preventDefault()\n    }\n  }\n\n  //Attach event listeners\n  const downListener = key.downHandler\n  const upListener = key.upHandler\n  \n  document.addEventListener(\n    \"keydown\", downListener, false\n  )\n  document.addEventListener(\n    \"keyup\", upListener, false\n  )\n  \n  // Detach event listeners\n  key.unsubscribe = () => {\n    document.removeEventListener(\"keydown\", downListener)\n    document.removeEventListener(\"keyup\", upListener)\n  }\n  \n  return key\n}","import styled from \"../../styled-components\";\n\n\nexport const Page = styled.div`\n  height: 100%;\n  width: 100%;\n  background-color: blueviolet;\n  /* display: flex; */\n  /* flex-direction: column; */\n  /* justify-content: center; */\n`\n\nexport const PixiViewWrapper = styled.div`\n`","import React from 'react'\nimport * as PIXI from 'pixi.js'\nimport * as s from './style'\nimport { \n  randomNumberInBetween, contain, Direction, \n  hitTestRectangle, keyboard, DirectionKeys \n} from './helpers';\n\nexport interface Sprite extends PIXI.Sprite {\n  vx: number\n  vy: number\n  centerX: number\n  centerY: number\n  halfWidth: number\n  halfHeight: number\n}\n\nconst SpriteID = {\n  door: 'door.png',\n  treasure: 'treasure.png',\n  explorer: 'explorer.png',\n  dungeon: 'dungeon.png',\n  blob: 'blob.png'\n}\ninterface AllSprites {\n  [x: string]: Array<Sprite> | Sprite\n  blobs: Array<Sprite>\n  door: Sprite,\n  treasure: Sprite,\n  explorer: Sprite,\n  dungeon: Sprite,\n}\n\ninterface HealthBarContainer extends PIXI.Container {\n  outer: PIXI.Graphics\n}\n\nexport interface AreaDims {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\nexport default class TreasureHunter extends React.Component {\n  pixiViewWrapperEle!: HTMLDivElement\n  pixiApp!: PIXI.Application\n  pixiLoader = PIXI.loader\n  allSprites = {} as AllSprites\n  gameTextures!: PIXI.loaders.TextureDictionary\n  gameState!: (deltaTime: number) => void\n  playScene!: PIXI.Container\n  gameOverScene!: PIXI.Container\n  healthBarContainer!: HealthBarContainer\n  movablePlaySceneAreaDims!: AreaDims\n  gameOverSceneMessage!: PIXI.Text\n  GAME_WIDTH = 1280\n  GAME_HEIGHT = 720\n  NumberOfBlobs = 100\n  DungeonWallWidth = 80\n  HealthBarWidth = 200\n  HealthBarHeight = 15\n\n  resize = () => {\n    // Determine which screen dimension is most constrained\n    const ratio = Math.min(window.innerWidth/this.GAME_WIDTH, window.innerHeight/this.GAME_HEIGHT)\n\n    // Scale the view appropriately to fill that dimension\n    this.pixiApp.stage.scale.x = this.pixiApp.stage.scale.y = ratio\n\n    // Update the renderer dimensions\n    this.pixiApp.renderer.resize(Math.ceil(this.GAME_WIDTH * ratio), Math.ceil(this.GAME_HEIGHT * ratio))\n\n    console.log(\"Resize\\n\" +\"  Window inner \" + window.innerWidth + \",\" + window.innerHeight +\n    \" pixel ratio \" + window.devicePixelRatio + \"\\n\" +\"  Renderer \" + this.pixiApp.renderer.width + \",\" +\n    this.pixiApp.renderer.height + \" res \" + this.pixiApp.renderer.resolution + \"\\n\" +\"  Scale \" + this.pixiApp.stage.scale.x + \",\" + this.pixiApp.stage.scale.y + \"\\n\")\n  }\n\n  setupGame = () => {\n    // The application will create a renderer using WebGL, if possible,\n    // with a fallback to a canvas render.\n    // It will also setup the ticker and the root stage PIXI.Container\n    this.pixiApp = new PIXI.Application({\n      width: this.GAME_WIDTH, height: this.GAME_HEIGHT, backgroundColor: 0x56a4b7, autoResize: true,\n      resolution: window.devicePixelRatio, antialias: true,\n    })\n    this.pixiApp.renderer.view.style.position = 'absolute'\n    this.pixiApp.renderer.view.style.top = '0px'\n    this.pixiApp.renderer.view.style.left = '0px'\n    this.resize()\n    this.pixiViewWrapperEle.appendChild(this.pixiApp.view)\n    window.addEventListener('resize', this.resize)\n    this.pixiLoader\n      .add({name: 'GameTextureAtlas', url: '/game-assets/pixi-treasure-hunter-game.json'})\n      .load(this.setupGameScenes)\n  }\n\n  setupGameScenes = (loader: PIXI.loaders.Loader, resources: PIXI.loaders.ResourceDictionary) => {\n    this.playScene = new PIXI.Container()\n    this.gameOverScene = new PIXI.Container()\n    this.gameOverScene.visible = false\n    \n    this.setupPlayGameScene(resources)\n    this.setupGameOverScene()\n\n    this.gameState = this.play\n    this.pixiApp.ticker.add(this.gameLoop)\n  }\n\n  setupPlayGameScene = (resources: PIXI.loaders.ResourceDictionary) => {\n    this.gameTextures = resources.GameTextureAtlas.textures as PIXI.loaders.TextureDictionary\n\n    this.createSpriteAndAddToPlayScene(SpriteID.dungeon, 0, 0)\n    this.allSprites.dungeon.width = this.GAME_WIDTH\n    this.allSprites.dungeon.height = this.GAME_HEIGHT\n    \n    this.createSpriteAndAddToPlayScene(SpriteID.explorer)\n    this.allSprites.explorer.x = this.DungeonWallWidth\n    this.allSprites.explorer.y = this.GAME_HEIGHT / 2 - this.allSprites.explorer.height / 2\n    this.allSprites.explorer.vx = 0\n    this.allSprites.explorer.vy = 0\n    this.bindKeyboardArrowKeysToExplorerMoves()\n    \n    this.createSpriteAndAddToPlayScene(SpriteID.treasure)\n    this.allSprites.treasure.x = this.GAME_WIDTH - this.allSprites.treasure.width - this.DungeonWallWidth\n    this.allSprites.treasure.y = this.GAME_HEIGHT / 2 - this.allSprites.treasure.height / 2\n\n    this.createSpriteAndAddToPlayScene(SpriteID.door, this.DungeonWallWidth, 0)\n\n    this.createBlobSprites(SpriteID.blob)\n\n    this.createHealthBar()\n\n    this.movablePlaySceneAreaDims = {\n      x: this.DungeonWallWidth, y: 20, \n      width: this.GAME_WIDTH - this.DungeonWallWidth, height: this.GAME_HEIGHT - 40\n    }\n\n    this.pixiApp.stage.addChild(this.playScene)\n  }\n\n  createSpriteAndAddToPlayScene = (spriteID: string, x?: number, y?: number, ) => {\n    const sprite = new PIXI.Sprite(this.gameTextures[spriteID]) as Sprite\n    if (typeof x === 'number' && typeof y === 'number') {\n      sprite.x = x\n      sprite.y = y\n    }\n    const spriteName = spriteID.substring(0, spriteID.length-4)\n    this.allSprites[spriteName] = sprite\n    this.playScene.addChild(sprite)\n  }\n\n  bindKeyboardArrowKeysToExplorerMoves = () => {\n    // Capture the keyboard arrow keys\n    const left = keyboard(DirectionKeys.ArrowLeft),\n          up = keyboard(DirectionKeys.ArrowUp),\n          right = keyboard(DirectionKeys.ArrowRight),\n          down = keyboard(DirectionKeys.ArrowDown)\n\n    const {explorer} = this.allSprites\n    \n    // Left arrow key `press` method\n    left.press = () => {\n      //Change the husky's velocity when the key is pressed\n      explorer.vx = -5\n      explorer.vy = 0;\n    }\n\n     // Left arrow key `release` method\n    left.release = () => {\n      // If the left arrow has been released, and the right arrow isn't down,\n      // and the husky isn't moving vertically:\n      // Stop the husky\n      if (!right.isDown && explorer.vy === 0) {\n        explorer.vx = 0\n      }\n    }\n\n    // Up\n    up.press = () => {\n      explorer.vy = -5\n      explorer.vx = 0\n    }\n    up.release = () => {\n      if (!down.isDown && explorer.vx === 0) {\n        explorer.vy = 0\n      }\n    }\n    // Right\n    right.press = () => {\n      explorer.vx = 5\n      explorer.vy = 0\n    }\n    right.release = () => {\n      if (!left.isDown && explorer.vy === 0) {\n        explorer.vx = 0\n      }\n    }\n    // Down\n    down.press = () => {\n      explorer.vy = 5\n      explorer.vx = 0\n    }\n    down.release = () => {\n      if (!up.isDown && explorer.vx === 0) {\n        explorer.vy = 0\n      }\n    }\n  }\n\n  createBlobSprites = (spriteID: string) => {\n    const blobSpritesArray = Array.from({length: this.NumberOfBlobs}) as Array<Sprite>\n    blobSpritesArray.forEach((_, idx, array) => {\n      const blobSprite = new PIXI.Sprite(this.gameTextures[spriteID]) as Sprite\n      array[idx] = blobSprite\n    })\n    this.allSprites.blobs = blobSpritesArray\n    this.positionBlobsRandomly()\n  }\n\n  positionBlobsRandomly = () => {\n    const offsetFromWall = this.DungeonWallWidth + 100\n    const blobToblobSpacing = 50\n    const speed = 2\n    let direction = 1\n    this.allSprites.blobs.forEach((blobSprite, idx) => {\n      blobSprite.x = randomNumberInBetween(offsetFromWall, this.GAME_WIDTH - offsetFromWall)\n      blobSprite.y = randomNumberInBetween(0, this.GAME_HEIGHT - blobSprite.height)\n      \n      //Set the blob's vertical velocity. `direction` will be either `1` or\n      //`-1`. `1` means the enemy will move down and `-1` means the blob will\n      //move up. Multiplying `direction` by `speed` determines the blob's\n      //vertical direction\n      blobSprite.vy = speed * direction\n\n      //Reverse the direction for the next blob\n      direction *= -1;\n\n      this.playScene.addChild(blobSprite)\n    })\n  }\n\n  createHealthBar = () => {\n    this.healthBarContainer = new PIXI.Container() as HealthBarContainer\n    \n    const label = new PIXI.Text('Health', {\n      fontFamily: \"Futura\",\n      fontSize: this.HealthBarHeight,\n      fill: \"white\"\n    })\n    label.position.set(0, 0)\n    this.healthBarContainer.addChild(label)\n\n    //Create the black background rectangle\n    const innerBar = new PIXI.Graphics()\n    innerBar.beginFill(0x000000)\n    innerBar.drawRect(label.width + 10, 0, this.HealthBarWidth, this.HealthBarHeight)\n    innerBar.endFill()\n    this.healthBarContainer.addChild(innerBar)\n\n    //Create the front red rectangle\n    const outerBar = new PIXI.Graphics()\n    outerBar.beginFill(0x00FF00)\n    outerBar.drawRect(label.width + 10, 0, this.HealthBarWidth, this.HealthBarHeight)\n    outerBar.endFill()\n    this.healthBarContainer.addChild(outerBar)\n\n    const healthBarXPosition = this.GAME_WIDTH - this.DungeonWallWidth - this.healthBarContainer.width\n    this.healthBarContainer.position.set(healthBarXPosition, 4)\n    this.healthBarContainer.outer = outerBar\n    this.playScene.addChild(this.healthBarContainer)\n  }\n\n  setupGameOverScene = () => {\n    const background = new PIXI.Graphics()\n    background.beginFill(0x058635)\n    background.drawRect(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT)\n    background.endFill()\n    this.gameOverScene.addChild(background)\n    \n    const style = new PIXI.TextStyle({\n      fontFamily: \"Futura\",\n      fontSize: 64,\n      fill: \"white\"\n    })\n    this.gameOverSceneMessage = new PIXI.Text('The End!', style)\n    this.gameOverSceneMessage.x = this.GAME_WIDTH / 2 - this.gameOverSceneMessage.width / 2\n    this.gameOverSceneMessage.y = this.GAME_HEIGHT / 2 - this.gameOverSceneMessage.height / 2\n    this.gameOverScene.addChild(this.gameOverSceneMessage)\n\n    this.pixiApp.stage.addChild(this.gameOverScene)\n  }\n\n  gameLoop = (deltaTime: number) => {\n    this.gameState(deltaTime)\n  }\n\n  play = (deltaTime: number) => {\n    //Move the explorer and contain it inside the dungeon\n    //Move the blob monsters\n    //Check for a collision between the blobs and the explorer\n    //Check for a collision between the explorer and the treasure\n    //Check for a collision between the treasure and the door\n    //Decide whether the game has been won or lost\n    //Change the game `state` to `end` when the game is finished\n    const {blobs, explorer, treasure, door} = this.allSprites\n    \n    explorer.x += explorer.vx\n    explorer.y += explorer.vy\n\n    contain(explorer, this.movablePlaySceneAreaDims)\n\n    let isExplorerHit = false\n    \n    blobs.forEach((blob) => {\n      //Move the blob\n      blob.y += blob.vy\n\n      //Check the blob's screen boundaries\n      let blobHitsWall = contain(blob, this.movablePlaySceneAreaDims)\n\n      //If the blob hits the top or bottom of the stage, reverse\n      //its direction\n      if (blobHitsWall === Direction.top || blobHitsWall === Direction.bottom) {\n        blob.vy *= -1\n      }\n\n      //Test for a collision. If any of the enemies are touching\n      //the explorer, set `explorerHit` to `true`\n      if(hitTestRectangle(explorer, blob)) {\n        isExplorerHit = true;\n      }\n    })\n    if(isExplorerHit) {\n      //Make the explorer semi-transparent\n      explorer.alpha = 0.5\n      //Reduce the width of the health bar's inner rectangle by 1 pixel\n      this.healthBarContainer.outer.width -= 1\n      //reset\n    } else {\n      //Make the explorer fully opaque (non-transparent) if it hasn't been hit\n      explorer.alpha = 1\n    }\n\n    if (hitTestRectangle(explorer, treasure)) {\n      treasure.x = explorer.x + 8\n      treasure.y = explorer.y + 8\n    }\n\n    if (hitTestRectangle(treasure, door)) {\n      this.gameState = this.end\n      this.gameOverSceneMessage.text = \"You won!\"\n    }\n\n    if (this.healthBarContainer.outer.width < 0) {\n      this.gameState = this.end\n      this.gameOverSceneMessage.text = \"You lost!\"\n    }\n  }\n\n  end = (deltaTime: number) => {\n    this.playScene.visible = false\n    this.gameOverScene.visible = true\n  }\n\n  componentDidMount = () => {\n    if (this.pixiViewWrapperEle) {\n      this.setupGame()\n    }\n  }\n\n  render() {\n    return (\n      <s.Page>\n        <s.PixiViewWrapper ref={((pixiViewWrapperEle: HTMLDivElement) => {this.pixiViewWrapperEle = pixiViewWrapperEle})}>\n        </s.PixiViewWrapper>\n      </s.Page>\n    )\n  }\n}","import React, { Component } from 'react'\nimport {ThemeProvider, css} from './styled-components'\nimport * as s from './AppStyle'\n// import Default from './pages/Default';\nimport TreasureHunter from './pages/TreasureHunter';\n\nexport default class App extends Component {\n  render() {\n    return (\n      <ThemeProvider theme={s.theme}>\n        <>\n          <s.GlobalStyle />\n          <s.AppWrapper>\n            {/* <Default /> */}\n            <TreasureHunter />\n          </s.AppWrapper>\n        </>\n      </ThemeProvider>\n    )\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}